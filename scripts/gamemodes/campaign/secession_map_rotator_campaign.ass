#include "map_rotator_invasion.as"

class SecessionMapRotatorCampaign : MapRotatorInvasion {
	protected array<string> m_trackedTriggerAreas;
	protected array<const XmlElement@> m_triggerAreas;

	protected int m_playerCharacterId;
	protected float m_localPlayerCheckTimer;
	protected float LOCAL_PLAYER_CHECK_TIME = 5.0;

	// --------------------------------------------
	SecessionMapRotatorCampaign(GameModeInvasion@ metagame) {
		super(metagame);

		m_playerCharacterId = -1;
		m_localPlayerCheckTimer = 0.0f;

        determineTriggerAreasList();
        refreshTriggerAreas();
	}

	// -------------------------------------------------------
	protected const array<const XmlElement@>@ getTriggerAreasList() const {
		return m_triggerAreas;
	}

	// --------------------------------------------------------
	protected void refreshTriggerAreas() {
		_log("** SECESSION REFRESH TRIGGER AREAS", 1);
		//clearHitboxAssociations(m_metagame, "character", m_playerCharacterId, m_trackedTriggerAreas);

		const array<const XmlElement@> list = getTriggerAreasList();
		if (list is null) return;

		array<string> addIds;
		enableTriggerAreas(m_metagame, list, "character", m_playerCharacterId, m_trackedTriggerAreas, addIds);
	}

	// --------------------------------------------
	protected void markTriggerAreas() {
		const array<const XmlElement@> list = getTriggerAreasList();
		if (list is null) return;

		// only show trigger area markers at screen edge if current map is complete
		//bool showAtScreenEdge = isStageCompleted(m_currentStageIndex);
        // debug:
        bool showAtScreenEdge = true;

		int offset = 2000;
		for (uint i = 0; i < list.size(); ++i) {
			const XmlElement@ triggerAreaNode = list[i];
			string id = triggerAreaNode.getStringAttribute("id");
			string text = "a trigger area";
			int atlasIndex = 1;
			float size = 1.0;
			string color = "#E0E0E0";
			string position = triggerAreaNode.getStringAttribute("position");

			string command = "<command class='set_marker' id='" + offset + "' faction_id='0' atlas_index='" + atlasIndex +
				"' text='" + text + "' position='" + position + "' color='" + color + "' size='" + size + "' show_at_screen_edge='" + (showAtScreenEdge?1:0) + "' />";
			m_metagame.getComms().send(command);

			offset++;
		}
	}

	// --------------------------------------------------------
	protected void unmarkTriggerAreas() {
		const array<const XmlElement@> list = getTriggerAreasList();
		if (list !is null) return;

		int offset = 2000;
		for (uint i = 0; i < list.size(); ++i) {
			string command = "<command class='set_marker' id='" + offset + "' enabled='0' />";
			m_metagame.getComms().send(command);
			offset++;
		}
	}

	// ----------------------------------------------------
	protected void setupCharacterForTracking(int id) {
		// it's the local player, do stuff now
		clearHitboxAssociations(m_metagame, "character", m_playerCharacterId, m_trackedTriggerAreas);
		m_playerCharacterId = id;

		_log("setting up tracking for character " + id, 1);

		const array<const XmlElement@> list = getTriggerAreasList();
		if (list !is null) {
			associateTriggerAreas(m_metagame, list, "character", m_playerCharacterId, m_trackedTriggerAreas);
		}
	}

	// ----------------------------------------------------
	protected void handlePlayerSpawnEvent(const XmlElement@ event) {
		_log("SecessionMapRotatorCampaign::handlePlayerSpawnEvent", 1);
		// don't care if already about to change map
		if (isAboutToChangeMap()) {
			_log("map change imminent. skipping", 1);
			return;
		}

		const XmlElement@ element = event.getFirstElementByTagName("player");
		string name = element.getStringAttribute("name");
		_log("player spawned: " + name + ", target username is " + m_metagame.getUserSettings().m_username, 1);
		if (name == m_metagame.getUserSettings().m_username) {
			_log("player is local", 1);
			setupCharacterForTracking(element.getIntAttribute("character_id"));
		}
	}

	// ----------------------------------------------------
	void update(float time) {
		// TODO: likely we could do this at gameContinuePreStart, but won't change now to avoid re-testing
		ensureValidLocalPlayer(time);
	}

	// ----------------------------------------------------
	protected void ensureValidLocalPlayer(float time) {
		if (m_playerCharacterId < 0) {
			m_localPlayerCheckTimer -= time;
			if (m_localPlayerCheckTimer < 0.0) {
				_log("tracked player character id " + m_playerCharacterId, 1);
				const XmlElement@ player = m_metagame.queryLocalPlayer();
				if (player !is null) {
					setupCharacterForTracking(player.getIntAttribute("character_id"));
				} else {
					_log("WARNING, local player query failed", -1);
				}
				m_localPlayerCheckTimer = LOCAL_PLAYER_CHECK_TIME;
			}
		}
	}

	// ----------------------------------------------------
	protected bool isAboutToChangeMap() const {
		return m_nextStageIndex != m_currentStageIndex;
	}

	// ----------------------------------------------------
	protected void handleHitboxEvent(const XmlElement@ event) {
        // handleHitboxEvent events return:
		// hitbox_id
		// instance_type (vehicle/character)
		// instance_id

		_log("secession_map_rotator_campaign: handle_hitbox_event, type=" + event.getStringAttribute("instance_type") +
			", id=" + event.getIntAttribute("instance_id") + ", triggerArea=" + event.getStringAttribute("hitbox_id"), 1);

		if (event.getStringAttribute("instance_type") == "character" &&
			event.getIntAttribute("instance_id") == m_playerCharacterId) {

			// this event concerns our master player
			_log("** player breached trigger area: " + event.getStringAttribute("hitbox_id"), 1);

			// clear hitbox checking now (I don't think we ever want to clear these)
			//clearHitboxAssociations(m_metagame, "character", m_playerCharacterId, m_trackedHitboxes);
		}
	}

	// -------------------------------------------------------
	protected const array<const XmlElement@>@ getTriggerAreasList() const {
		// return cached stuff
		return m_triggerAreas;
	}

	// -------------------------------------------------------
	protected void determineTriggerAreasList() {
		array<const XmlElement@> list;
		_log("** SECESSION map_rotator_campaign: determineTriggerAreasList", 1);

    	list = getTriggerAreas(m_metagame);
			// go through the list and only leave the ones in we're interested in, 'hitbox_trigger*'
			for (uint i = 0; i < list.size(); ++i) {
				const XmlElement@ triggerAreaNode = list[i];
				string id = triggerAreaNode.getStringAttribute("id");
				bool ruleOut = false;
				if (id.findFirst("hitbox_trigger") < 0) {
					ruleOut = true;

				if (ruleOut) {
					_log("secession_map_rotator_campaign determineTriggerAreasList: ruling out " + id, 1);
					list.erase(i);
					i--;
				} else {
					_log("including " + id, 1);
				}
			}
			_log("* " + list.size() + " trigger areas found");
		}

		m_triggerAreas = list;
		markTriggerAreas();
	}

	// --------------------------------------------
    void startMap(int index, bool beginOnly = false) {
		// let vanilla handle this
        //MapRotatorInvasion::startMap(index, beginOnly);

        // we want this to happen, though
		determineTriggerAreasList();
		refreshTriggerAreas();
	}

	// --------------------------------------------
	void load(const XmlElement@ root) {
        determineTriggerAreasList();
        refreshTriggerAreas();
	}
}
